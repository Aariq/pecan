---
title: "PEcAn.assim.batch Vignette"
author: 
- "Istem Fer"
- "Ryan Kelly"
date: "November 15, 2021"
output: html_vignette
vignette: >
  %\VignetteIndexEntry{PEcAn.assim.batch Vignette}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

## Install package from Github

Only needs to be done the first time :
```{r, eval=FALSE}
library(devtools)
install_github("PecanProject/pecan", subdir="all")
```

## Parameter Data Assimilation (a.k.a. calibration) in PEcAn

Currently, there are three ways of doing Parameter Data Assimilation (PDA) in PEcAn :

- bayesian.tools (bruteforce algorithms)
- emulator
- multi-site hierarchical PDA (HPDA) with emulators

Note that, there used to be Metropolis-Hastings Markov Chain Monte Carlo (MCMC) algorithms implemented natively in PEcAn, namely `/modules/assim.batch/R/pda.mcmc.R` and `pda.mcmc.bs.R`. These are deprecated and they will no longer be maintained.

**Which one to use?**

**bayesian.tools :** The `pda.bayesian.tools.R` is the main script of this PDA workflow that performs a bruteforce (MCMC methods that require running your models at least couple of thousand of times) calibration. This script uses the `BayesianTools` R-package (Hartig, Minuno and Paul, 2019) that includes MCMC and SMC samplers and other tools for Bayesian parameter calibration with external models. If you choose *bayesian.tools* option, PEcAn framework will hand the PDA calculations over to the `BayesianTools` package. Although this package includes algorithms that are designed to explore the parameter space more efficiently than the traditional MH-MCMC, you would still need a relatively faster model to use these algorithms. Note that the `BayesianTools` R-package itself is constantly under development, and its integration with PEcAn may not be possible to leverage all `BayesianTools` functionality through PEcAn.

**emulator :** The `pda.emulator.R` is the main script of this PDA workflow. When a model is slow, it is practically not possible to run it hundreds of thousands of times sequentially to explore the parameter space and draw enough samples to converge the target distribution with bruteforce algorithms. Instead, we can run the model for a relatively smaller number of times with parameter combinations that have been carefully chosen to give good coverage of parameter space. Then we can interpolate the likelihood calculated for each of those runs to get a surface that "emulates" the true likelihood and perform regular MCMC (just like the "bruteforce" approach), except instead of actually running the model on every iteration to obtain a likelihood value, this time we will just get an approximation from the likelihood emulator. A lot more details about the emulator approach can be found in [Fer et al. 2018.](https://doi.org/10.5194/bg-15-5801-2018)

**Multi-site HPDA :** The `pda.emulator.ms.R` is the main script of this PDA workflow which performs a multi-site hierarchical Bayesian calibration using the emulator approach. In the multi-site hierarhical calibration, global posteriors are fitted simultaneously using an additional Gibbs update step, and used as the new prior hyperparameters in the next iteration of MCMC to obtain site-level hierarchical posteriors. This PDA workflow has its own vignette (see `/modules/assim.batch/vignettes/MultiSitePDAVignette.Rmd`) and will not be one of the examples here. For more information also see [Fer et al. 2021 bioRxiv preprint](https://doi.org/10.1101/2021.04.28.441243).

## Adding PDA tags to pecan.xml

The easiest way to use PEcAn's parameter data assimilation module is to add an `<assim.batch>` block to pecan.xml, load the file with `read.settings`, and pass the resulting settings object to `pda.bayesian.tools()` or `pda.emulator()`. There are some differences in the settings for using different PDA methods (we will go through test cases, at this point just familiarize yourself with the general pattern), but here is an example `<assim.batch>` block :

```
<assim.batch>
  <iter>100000</iter>
  <method>emulator</method>                     <--- WHICH PDA APPROACH
  <chain>3</chain>
  <param.names>
   <temperate.coniferous>                       <--- YOUR PFT(S)
    <param>PARAM1</param>                       <--- PARAMETER(S) YOU TARGET IN PDA
    <param>PARAM2</param>
   </temperate.coniferous>
  </param.names>
  <inputs>
    <file>
      <input.id> ... </input.id>                <--- YOUR CONSTRAINT ID FROM BETY DB 
      <path>
        <path> ... </path>                      <--- YOUR CONSTRAINT FILE PATH
        <path> ... </path>
      </path>
      <likelihood>Laplace</likelihood>          <--- LIKELIHOOD FORM FOR THIS CONSTRAINT 
      <variable.id>298</variable.id>            <--- (CONSTRAINT) VARIABLE ID FROM BETY DB
      <variable.name>
        <variable.name>LE</variable.name>       <--- (CONSTRAINT) VARIABLE
        <variable.name>UST</variable.name>      <--- HELPER VARIABLE SPECIFIC TO FLUX CASE
      </variable.name>
    </file>
  </inputs>
  <inputs>
    <file>
      <input.id>...</input.id>
      <path>
        <path>...</path>
      </path>
    <likelihood>multipGauss</likelihood>
    <hyper.pars>
      <parama>0.001</parama>                    <--- HYPERPARAMETERS SPECIFIC TO GAUSSIAN FORM
      <paramb>0.001</paramb>
    </hyper.pars>
    <ss.positive>TRUE</ss.positive>
      <variable.name>
        <variable.name>...</variable.name>
      </variable.name>
    </file>
  </inputs>
</assim.batch>
```


Here are some more details about the PDA tags:


* `<iter>` Specifies the number of MCMC iterations to run. If continuing a previous MCMC, this is the number of additional iterations, which will be added to the previous total. Defaults to 100 if missing. 

* `<chain>` Specifies the number of MCMC chains to be run.

* `<prior>` Identifies the prior to be used for PDA. Can be one of either:

       + `<posterior.id>` A posterior ID in BETY specifying the posterior from a previous PEcAn analysis (e.g., meta-analysis or previous PDA) to be used as the prior for PDA. Defaults to the most recent relevant posterior in the database if omitted (and no `<path>` specified instead; see below).

       + `<path>` As an alternative to using a posterior ID, can specify a file path to either a `prior.distns.Rdata` or `post.distns.Rdata` file generated from an earlier analysis. Conceptually, using a posterior distribution as the prior for PDA is preferred, as this allows the multiple analyses to work together to iteratively constrain parameters. In practice, previous analyses may have over-constrained parameters to ranges that do not actually optimize model outputs, so using a less informative prior for PDA might yield better results. 
       
       NOTE: It is recommended to leave the `<prior>` tag empty if you are doing this for the first time. PEcAn workflow will handle it for you.

* `<param.names>` The names of parameters to be constrained by assimilation, listed in individual `<param>` tags. *These must be the standard names given in BETY DB, not your model specific parameter names*, i.e. check out the `id` column of the `trait.dictionary`, i.e. :

```{r}
data(trait.dictionary, package = "PEcAn.utils")

head(trait.dictionary[,c("id", "figid")])
```

           NOTE : `<param.names>` chunk should always be on your xml file regardless of the method you use in the PDA.
           
* `<inputs>` Observation (constraint) data to be compared to the model. In principle, can be one or more datasets, specified in a variety of ways. In practice, the code is tested for assimilating flux datasets numerous times using the NEE/FC or LE variables. 

     
    + `<file>` Denotes a set of tags for a single input. Would be repeated for multiple datasets/variables, e.g. in this case note the differences in `<variable.id>` and `<variable.name>` :
    
    ```
    ...
    <inputs>
      <file>
        <input.id>1000000384</input.id>
        <path>
          <path>/fs/data1/pecan.data/input/Ameriflux_site_0-796/US-Bar.2005.nc</path>
          <path>/fs/data1/pecan.data/input/Ameriflux_site_0-796/US-Bar.2006.nc</path>
        </path>
        <likelihood>Laplace</likelihood>
        <variable.id>298</variable.id>
        <variable.name>
          <variable.name>LE</variable.name>
          <variable.name>UST</variable.name>
        </variable.name>
      </file>
      <file>
        <input.id>1000000384</input.id>
        <path>
          <path>/fs/data1/pecan.data/input/Ameriflux_site_0-796/US-Bar.2005.nc</path>
          <path>/fs/data1/pecan.data/input/Ameriflux_site_0-796/US-Bar.2006.nc</path>
        </path>
        <likelihood>Laplace</likelihood>
        <variable.id>1000000042</variable.id>
        <variable.name>
          <variable.name>FC</variable.name>
          <variable.name>UST</variable.name>
        </variable.name>
      </file>
    </inputs>
    ...
    ```
    + `<input.id>` BETY input ID for looking up the input. 
    + `<path>` File path to the input. Both `<id>` and `<path>` of the observation data should be supplied for the PDA. 
    + `<source>` A standardized source of input data (e.g., Ameriflux). Not implemented yet, but the idea would be similar to the met workflow, PEcAn would be able to use standard data sources automatically where available. Only used if no `<id>` or `<path>` is given.
      + `<likelihood>` Identifier for the likelihood to use. E.g., the Ameriflux NEE/FC and LE data use a Laplacian likelihood. 
      + `<hyper.pars>` Optional. Hyperparameters for your likelihood. E.g. Prior parameters of the precision for Gaussian likelihood. Defaults to scaled values if not provided. 
      + `<variable.id>` The BETY variable ID associated with this dataset. The idea is that specific preprocessing steps (e.g., estimating heteroskedastic error for tower NEE) would be associated with particular IDs. Could automate further by assigning default `<likelihood>` to variable.id values (allowing `<likelihood>` to be omitted from pecan.xml). 
      
           NOTE : `<inputs>` chunk should always be on your xml file regardless of the method you use in the PDA.
           
           
* `<jump>` Settings for the specifics of the proposal schema and adaptation functionality. 
     + `<ar.target>` Target acceptance rate for the adaptive jump algorithm. Defaults to 0.5 if missing. 
     + `<adapt>` Number of iterations between jump variance adaptations. Defaults to `floor(iter/10)` if missing. If set equal to the number of `<iter>`, basically turns off the adaptation functionality, it is not recommended to turn-off this functionality.
     + `<adj.min>` Minimum factor by which to reduce jump variance when adapting. Prevents jump variances from degenerating to 0. Defaults to 0.1 if missing. 
* `<diag.plot.iter>` Interval between saving diagnostic plots. Omit or set to NULL to skip them.
* `<params.id>` (Not shown.) A BETY dbfile ID for an MCMC output from previous PDA. If specified, that file is loaded, the new MCMC starts from the last parameter values of the previous, and when finished the extended chain is saved as a new output. If missing, then MCMC starts fresh from prior median parameter values. Regardless, the MCMC parameter values of the PDA are saved to file and inserted in BETY, and the new dbfile ID is inserted into `<params.id>`. The `pda.mcmc()` funtion returns the `<assim.batch>` settings, which can then be saved. Then, calling a new round of PDA using these returned settings will automatically continue the previous MCMC. 



## Method specific settings

If you want to extend your previous *bruteforce* and *bruteforce.bs* MCMC-chains, you can add an `<extension>` tag within your `<assim.batch>` chunk after reading your post-PDA settings (which would be saved as "pecan.pda[UNIQUE_ID].xml" in your working directory) and set it to "longer". 

```
  ...
  <method>bruteforce.bs</method>
  <iter>10000</iter>
  <method>bruteforce</method>
  <chain>3</chain>
  <extension>longer</extension>
  ...
```

If you are using methods other than *bruteforce* and *bruteforce.bs*, some additional tags and different settings may apply. 

**emulator** would use additional tags:
```
  ...
  <method>emulator</method>
  <n.knot>20</n.knot>
  <GPpckg>GPfit</GPpckg>
  <chain>3</chain>
  <extension>round</extension>
  <knot.par>0.75</knot.par>
  ...
```
* `<n.knot>` Specifies the number of locations in parameter space to be sampled by the Latin Hypercube design. These locations are where the model will actually be run. In other words the model will be run for `<n.knots>` times. 

* `<GPpckg>` Specifies which R package to use for fitting a Gaussian process to interpolate the likelihood surface in between the calculated values that are obtained from actual model runs. Current options are `kernlab` and `GPfit` (recommended). 

* `<chain>` Specifies the number of MCMC chains to be run.

* `<extension>` Specifies the extension type of additional emulator runs, should be skipped if this a first emulator run of its own. Otherwise it is possible to extend emulator PDA runs in two ways:      

    + `<extension>longer</extension>` using the same emulator, this extension run takes the MCMC sampling from where it was left in the previous emulator run and runs a longer MCMC chain.
     
    + `<extension>round</extension>` this extension run proposes new points in the parameter space in addition to the previous ones, and builds a new emulator including these additional points for a new MCMC sampling. These new points can come from both your inital PDA prior and the posterior of your first round of emulator run. You can determine the percentage of new knots coming from the posterior of your previous run in the `<knot.par>` tag. If you leave it empty, 75% of your new points will be drawn from the posterior of your previous run by default.

```
      <file>
        <input.id>...</input.id>
        <path>
          <path>...</path>
        </path>
        <likelihood>multipGauss</likelihood>
        <ss.positive>TRUE</ss.positive>
        <variable.id>...</variable.id>
        <variable.name>
          <variable.name>...</variable.name>
        </variable.name>
      </file>
    </inputs>
```

* `<ss.positive>` When using the emulator, it is important to let the algorithm know that you have a likelihood whose sufficient statistics is zero bound. 

**bayesian.tools** would look for sampler specific settings that can be passed through the pecan.xml as a block under the `<bt.settings>` tag. Currently, the available samplers in the BayesianTools package are:

* Metropolis
     + Standard MH-MCMC
     + With pre-optimization
     + Adaptive MCMC
     + Delayed rejection
     + Gibbs updating
* M : Another implementation of standard MH-MCMC.
* AM : Adaptive Metropolis
* DR : Delayed Rejection
* DRAM : Delayed Rejection Adaptive Metropolis
* DE : Differential Evolution 
* DEzs : Differential Evolution with a snooker updater
* DREAM : Differential Evolution Adaptive Metropolis 
* DREAMzs : Differential Evolution Adaptive Metropolis with a snooker updater
* Twalk : "traverse" or "thoughtful" walk, a general purpose sampling algorithm
* SMC : Sequential Monte Carlo

The name of the chosen sampler would be passed under `<sampler>` tag within the `<bt.settings>` block :

It is not possible to use some of the samplers in this package for univariate cases. The ones that you can use for univariate cases are: "Metropolis", "DE", "DEzs" and "Twalk".

For Metropolis variations:
```
  ...
  <method>bayesian.tools</method>
  <bt.settings>
    <iter>10000</iter>
    <sampler>Metropolis</sampler>
    <DRlevels>1</DRlevels>                               <-- set 2 for Delayed Rejection
    <optimize>FALSE</optimize>                           <-- set TRUE for pre-optimization
    <adapt>FALSE</adapt>                                 <-- set TRUE for Adaptive Metropolis
    <adaptationNotBefore>500</adaptationNotBefore>       <-- set for Adaptive Metropolis
  </bt.settings>
  ...
```

Some of the samplers are also restartable : "Metropolis", "DE", "DEzs", "DREAM", "DREAMzs", "Twalk"