
##' Load met data from PEcAn formatted met driver
##'
##' subsets a PEcAn formatted met driver file and converts to a data.table / data.frame object
##' @title load CF met
##' @param met.nc object of class ncdf4 representing an open CF compliant, PEcAn standard netcdf file with met data
##' @param lat numeric value of latutude
##' @param lon numeric value of longitude
##' @param start.date format is "YYYY-MM-DD"
##' @param end.date format is "YYYY-MM-DD"
##' @return data.table of met data
##' @author David LeBauer
load.cfmet <- cruncep_nc2dt <- function(met.nc, lat, lon, start.date, end.date){
  
  ## Lat and Lon
  Lat <- ncvar_get(met.nc, "lat")
  Lon <- ncvar_get(met.nc, "lon")
  
  lati <- which.min(abs(Lat - lat))
  loni <- which.min(abs(Lon - lon))
  
  time.idx <- ncvar_get(met.nc, "time")
  
  time.units <- unlist(strsplit(met.nc$dim$time$units, " since "))
  ref.date <- ymd_hms(time.units[2])
  if(grepl("hours", time.units[1])){
    time.idx <- ud.convert(time.idx, "hours", "days")
  }
  
  all.dates <- data.table(index = seq(time.idx),
                          date = ymd(ref.date) +
                            days(floor(time.idx)) +
                            minutes(ud.convert(time.idx - floor(time.idx), "days", "minutes")))
  
  # below commented out because of error with data.table http://stackoverflow.com/q/24501245/513006
  #   run.dates <- all.dates[date > ymd(start.date) & date < ymd(end.date),
  #                          list(index, date, doy = yday(date),
  #                               year = year(date), month = month(date),
  #                               day  = day(date), hour = hour(date))]
  run.dates <- with(all.dates[all.dates$date > ymd(start.date) & all.dates$date < ymd(end.date),],
                    data.table(index, date, doy = yday(date),
                               year = lubridate::year(date), month = lubridate::month(date),
                               day  = lubridate::day(date), hour = lubridate::hour(date)))
  
  currentlat <- round(lat, 2)
  currentlon <- round(lon, 2)
  results <- list()
  

  
  #    variables <- c("lwdown", "press", "qair", "rain", "swdown", "tair", "northward_wind", "eastward_wind")

  variables <- attributes(met.nc$var)$names
  
  ## modification of ncvar_get to function independent of dimension order
  ## see http://stackoverflow.com/a/22944715/199217
  ## should be generalized, perhaps to pass arguments "start" and "count" directly
  
  vars <- lapply(variables, function(x) get.ncvector(x, lati = lati, loni = loni, run.dates = run.dates, met.nc = met.nc))
  
  names(vars) <- variables
  
  result <- cbind(run.dates, as.data.table(vars[!sapply(vars, is.null)]))
  if(!"wind" %in% variables){
    if(all(c("northward_wind", "eastward_wind") %in% variables)){
      result$wind <- sqrt(result$northward_wind^2 + result$eastward_wind^2)
    }
  }
  return(result)
}


##' Temporal downscaling of daily or subdaily met data
##'
##' @title Downscale CF met data
##' @param cfmet data.table with CF variables generated by \code{\link{load.cfmet}}  
##' @param output.dt time step for output
##' @return downscaled result
##' @author David LeBauer
cfmet.temporal.downscale <- cruncep_hourly <- function(cfmet, lat, output.dt = 1){
  ## rename function to temporal_downscale?
  ## time step
  dt <- result[1:2,(as.duration(diff(date)))]
  dt_hr <- ud.convert(as.numeric(as.duration(dt)), "seconds", "hours")
  if(dt_hr >= 24){
    stop("only sub-daily downscaling supported")
  }
  
  new.date <- result[,list(hour = 0:(23 / output.dt) / output.dt),
                     by = c("year", "month", "day", "doy")]
  
  new.date$date <- new.date[,list(date = ymd(paste(year, month, day)) + hours(hour))]
  
  ## tests
  ## min(result$date) == min(new.date$date)
  ## max(result$date) == max(new.date$date)
  
  ## converting surface_downwelling_shortwave_flux_in_air from W/m2 avg to PPFD
  
  solarMJ <- ud.convert(result$surface_downwelling_shortwave_flux_in_air, paste0("W ", dt_hr, "h"), "MJ")
  PAR <- 0.486 * solarMJ ## Cambell and Norman 1998 p 151, ch 10
  result$ppfd <- ud.convert(PAR, "mol s", "micromol h")
  
  downscaled.result <- list()
  downscaled.result[["surface_downwelling_shortwave_flux_in_air"]] <- result$surface_downwelling_shortwave_flux_in_air 
  downscaled.result[["ppfd"]] <- result$ppfd
  for(var in c("surface_pressure", "specific_humidity",
               "precipitation_flux", "air_temperature", "wind", "surface_downwelling_shortwave_flux_in_air", "ppfd")){
    if(var %in% colnames(result)){
      ## convert units from 6 hourly to hourly
      hrscale <- ifelse(var %in%
                          c("surface_downwelling_shortwave_flux_in_air",
                            "precipitation_flux"),
                        dt_hr, 1)
      
      f <- splinefun(as.numeric(result$date), (result[[var]] / hrscale), method = "monoH.FC")
      if(var == "air_temperature"){
        downscaled.result[[var]] <- f(as.numeric(new.date$date))
      } else {
        downscaled.result[[var]] <- f(as.numeric(new.date$date))
        downscaled.result[[var]][downscaled.result[[var]]<0] <- 0
      }
    }
  }
  
  
  
  downscaled.result <- cbind(new.date, as.data.table(downscaled.result))#[date <= max(result$date),]
  
  if(downscaled.result[,list(h = length(unique(hour))), by = c("year", "doy")][,all(unique(h) != 24)]){
    print(cruncep.file)
    print(downscaled.result[,unique(year)])
    stop("some days don't have 24 hours")
  }
  return(downscaled.result)
}

##' Get time series vector from netCDF file
##'
##' internal convenience function for
##' streamlining extraction of data from netCDF files
##' with CF-compliant variable names
##' 
##' @title Get time series vector from netCDF file
##' @param var 
##' @param lati 
##' @param loni 
##' @param run.dates 
##' @param met.nc netcdf file with CF variable names
##' @return numeric vector
##' @author David Shaner LeBauer
get.ncvector <- function(var, lati = lati, loni = loni,
                         run.dates = run.dates, met.nc){
  
  start.idx = c(lat = lati, lon = loni, time = run.dates$index[1])
  count.idx = c(lat = 1, lon = 1, time = nrow(run.dates))
  dim.order <- sapply(met.nc$var$air_temperature$dim, function(x) x$name)
  ncvar_get2 <- function(var){
    ans <-  ncvar_get(nc = met.nc, varid = var,
                      start = start.idx[dim.order],
                      count = count.idx[dim.order])
    return(as.numeric(ans))
  }
  
  if(var %in% attributes(met.nc$var)$names){
    ans <- ncvar_get2(var)
  } else if (var == "surface_pressure"){
    ans <- 1013.25
  } else if (var == "wind"){
    ans <- sqrt(ncvar_get2("northward_wind")^2 + ncvar_get2("eastward_wind")^2)
  } else {
    ans <- NULL
  }
  return(ans)
}