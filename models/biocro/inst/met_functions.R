cruncep_nc2dt <- function(lat, lon, met.nc, start.date, end.date){


    ## Lat and Lon
    Lat <- ncvar_get(met.nc, "lat")
    Lon <- ncvar_get(met.nc, "lon")

    lati <- which.min(abs(Lat - lat))
    loni <- which.min(abs(Lon - lon))

    time.idx <- ncvar_get(met.nc, "time")

    all.dates <- data.table(index = seq(time.idx),
                            date = ymd("1700-01-01") +
                            days(floor(time.idx)) +
                            hours(24*(time.idx - floor(time.idx))))
    run.dates <- all.dates[date > ymd(start.date) & date < ymd(end.date),
                           list(index, date, doy = yday(date),
                                year = year(date), month = month(date),
                                day  = day(date), hour = hour(date))]
    
    currentlat <- round(lat, 2)
    currentlon <- round(lon, 2)
    results <- list()
     
    vars <- list()
 
    mask <- ncvar_get(nc = met.nc, varid = "mask",
                      start = c(loni, lati),
                      count = c(1,1)) 
    
    variables <- c("lwdown", "press", "qair", "rain", "swdown", "tair", "uwind", "vwind")
    if(mask == -1) {
        stop(paste("chosen lat:", lat, "and  lon:", lon, " is in the ocean"))
    } else if (mask > 0){
        ## modification of ncvar_get to function independent of dimension order
        ## see http://stackoverflow.com/a/22944715/199217
        ## should be generalized, perhaps to pass arguments "start" and "count" directly
        get.ncvar <- function(var, lati = lati, loni = loni,
                              run.dates = run.dates){
            start.idx = c(lat = lati, lon = loni, time = run.dates$index[1])
            count.idx = c(lat = 1, lon = 1, time = nrow(run.dates))
            dim.order <- sapply(met.nc$var$lwdown$dim, function(x) x$name) 
            ans <- as.numeric(ncvar_get(nc = met.nc,
                                        varid = var,
                                        start = start.idx[dim.order],
                                        count = count.idx[dim.order]))
            
            return(ans)
        }
        
        ## if the above throws an error ... 
        ## vars <- parallel::mclapply(variables, function(x) get.ncvar(x, lati = lati, loni = loni, run.dates = run.dates), mc.allow.recursive = TRUE)
        vars <- lapply(variables, function(x) get.ncvar(x, lati = lati, loni = loni, run.dates = run.dates))
        names(vars) <- variables
    }
    
    result <- cbind(run.dates, as.data.table(vars))
    result$wind <- result[,list(wind = sqrt(uwind^2 + vwind^2))]
    return(result)   
}
 
cruncep_hourly <- function(result, lat){
    
    new.date <- result[,list(hour = c(0:23)),
                       by = c("year", "month", "day", "doy")]

    new.date$date <- new.date[,list(date = ymd(paste(year, month, day)) + hours(hour))]
    
    ## tests
    ## min(result$date) == min(new.date$date)
    ## max(result$date) == max(new.date$date)

    ## converting swdown from W/m2 avg to PPFD

    solarMJ <- ud.convert(result$swdown, "W 6h", "MJ")
    PAR <- 0.486 * solarMJ ## Cambell and Norman 1998 p 151, ch 10
    result$ppfd <- ud.convert(PAR, "mol s", "micromol h")

    hourly.result <- list()
    hourly.result[["swdown"]] <- result$swdown 
    hourly.result[["ppfd"]] <- result$ppfd
    for(var in c("press", "qair", "rain", "tair", "wind", "swdown", "ppfd")){
        
        ## convert units from 6 hourly to hourly
        hrscale <- ifelse(var %in% c("swdown", "rain"), 6, 1)
        
        #f <- approxfun(as.numeric(result$date), (result[[var]] / hrscale), rule = 2)
        f <- splinefun(as.numeric(result$date), (result[[var]] / hrscale), method = "monoH.FC")
        if(var == "tair"){
            hourly.result[[var]] <- f(as.numeric(new.date$date))
        } else {
            hourly.result[[var]] <- f(as.numeric(new.date$date))
            hourly.result[[var]][hourly.result[[var]]<0] <- 0
        }
    }


                                                            
    new.result <- cbind(new.date, as.data.table(hourly.result))#[date <= max(result$date),]
    
    if(new.result[,list(h = length(unique(hour))), by = c("year", "doy")][,all(unique(h) != 24)]){
        print(cruncep.file)
        print(new.result[,unique(year)])
        stop("some days don't have 24 hours")
    }
    return(new.result)
}

qair2rh <- function(qair, temp, press = 1013.25){
    es <-  6.112 * exp((17.67 * temp)/(temp + 243.5))
    e <- qair * press / (0.378 * qair + 0.622)
    rh <- e / es
    rh[rh > 1] <- 1
    rh[rh < 0] <- 0

    return(rh)
}

cruncep_dt2weather <- function(weather = result, adjust=TRUE){

    x <- weather[,list(year, doy = doy, hour = hour,
                       solarR   = ppfd, 
                       DailyTemp.C = ud.convert(tair, "Kelvin", "Celsius"),
                       RH = qair2rh(qair = qair, temp = ud.convert(tair, "Kelvin", "Celsius"), press = ud.convert(press, "Pa", "mbar")),
                       WindSpeed  = wind,                       
                       precip = rain)]
    return(x)
}

get.weather <- function(lat, lon, met.nc = met.nc, start.date, end.date){
    if(!is.land(lat, lon)) stop("point is in ocean")
    result <- cruncep_nc2dt(lat = lat, lon = lon, met.nc = met.nc, start.date, end.date)
    new.result <- cruncep_hourly(result, lat = lat)
    weather <- cruncep_dt2weather(new.result)
}

get.soil <- function(lat, lon, soil.nc = soil.nc){
    
    ## Lat and Lon
    Lat <- ncvar_get(soil.nc, "lat")
    Lon <- ncvar_get(soil.nc, "lon")

    lati <- which.min(abs(Lat - lat))
    loni <- which.min(abs(Lon - lon))

    ## topsoil
    usda_class <- ncvar_get(soil.nc, "t_usda_tex",
                            start = c(loni, lati),
                            count = c(1,1))
    ref_depth <- ud.convert(ncvar_get(soil.nc, "ref_depth",
                           start = c(loni, lati),
                           count = c(1, 1)), "cm", "m")
    return(list(usda_class = usda_class, ref_depth = ref_depth))
}

is.land <- function(lat, lon){
    Lat <- ncvar_get(nc = met.nc, varid = "lat")
    Lon <- ncvar_get(nc = met.nc, varid = "lon")
    lati <- which.min(abs(Lat-lat))
    loni <- which.min(abs(Lon-lon))
    mask <- ncvar_get(nc = met.nc, varid = "mask",
                      start = c(loni, lati), count = c(1,1))
    return(mask >= 0)
}

get.latlonbox <- function(lati, loni, Lat = Lat, Lon = Lon){
    lat <- c(mean(Lat[lati:(lati-1)]), mean(Lat[lati:(lati+1)]))
    lon <- c(mean(Lon[loni:(loni-1)]), mean(Lon[loni:(loni+1)]))
    return(c(sort(lat), sort(lon)))
}

get.cruncep <- function(lat, lon, start.date, end.date){
    result <- cruncep_nc2dt(lat, lon)
    new.result <- cruncep_hourly(result, lat = Lat[lati])
    weather <- cruncep_dt2weather(new.result)
    return(weather)
}


getNARRforBioCro<-function(lat,lon,year){
    USlayer<-read.table("/home/groups/ebimodeling/met/NARR/ProcessedNARR/NARRindex.txt")
    index <- which.min((lat - USlayer$Latt)^2 + (lon - USlayer$Lonn))
    i <- USlayer$Iindex[index]
    j <- USlayer$Jindex[index]
    filename <- paste("/home/groups/ebimodeling/met/NARR/ProcessedNARR/",year,formatC(i,width=3,flag=0),formatC(j,width=3,flag=0),".RData",sep="")
    load(filename)
    return(dat)
}
